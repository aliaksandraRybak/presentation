<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>ES6 classes</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/solarized.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section class="greeting">
					<h1 style="font-size: 3.5em">{ES6}</h1>
					<h2 style="font-size: 2em"> classes &amp; inheritance</h2>
					<p style="margin: 100px 0 20px; font-size: 0.7em">Created by <a href="https://github.com/aliaksandraRybak" target="_blank">Aliaksandra Rybak</a></p>


					<aside class="notes">
						Hello everyone, my name is Alex and thee topic of my presentation is ES6 classes and inheritance.
					</aside>
				</section>

				<section>
					<h2>Some background info</h2>
					<p>In the early history of the JS, a cloud of animosity formed over the lack of a proper syntax for defining classes. The ES6 spec has introduced the <strong><span style="color: #901818">class</span></strong> keyword. This presentation will show what ES6 offers us regarding to classes.</p>


					<aside class="notes">
						In the early history of the JavaScript language, a cloud of animosity formed over the lack of a proper syntax for defining classes like in most object oriented languages. It wasn’t until the ES6 spec release in 2015 that the class keyword was introduced. This presentation will show us what ES6 offers us regarding to classes.
						At its most basic level, the class keyword in ES6 is described as syntactical sugar over the existing prototype-based inheritance and is equivalent to a constructor function definition. Though it may seem redundant that a new keyword was introduced to wrap an already existing feature, it leads to readable code and lays the foundation upon which future object oriented features can be built.
					</aside>
				</section>

				<section>
					<h2>Defining classes</h2>
					<pre>
						<code data-trim>
							class Character {};


							//unnamed
							const character = class {};


							//named
							const char = class Character {};
						</code>
					</pre>


					<aside class="notes">
						Making a transition from using the older object constructors to the newer ES6 classes shouldn’t be difficult since the class keyword is just a special function and exhibits expected function behavior. For example, just like a function, a class can be defined by either a declaration or an expression, where the latter can be named or unnamed. It is worthy of noting that they are not hoisted, though.
					</aside>
				</section>

				<section>
					<section>
						<h2 style="font-size: 1.4em">Simple class example</h2>
						<pre>
							<code data-trim>
								class Character {
									constructor(name, health, damage) {
										this.name = name;
										this.health = health;
										this.damage = damage;
									}
								}
							</code>
						</pre>


						<aside class="notes">
							Let's take a look at the simple class of a game character. A distinctive feature of classes is the function called constructor. It is simply a method which purpose is to initialize an instance of the class. This means that whenever an instance of a class is created, the constructor of the class is invoked automatically to do something on that instance; it could maybe initialize the object’s properties with received parameters or default values when the former aren’t available.
						</aside>
					</section>

					<section>
						<h2 style="font-size: 1.4em">Getters and setters</h2>
						<pre>
							<code data-trim>
								get currName() {
									return `${this.name}`;
								}

								set currName(value) {
									this.name = value;
								}
							</code>
						</pre>


						<aside class="notes">
							ES6 classes bring new syntax for getters and setters on object properties. Get and set allows us to run code on the reading or writing of a property. The get syntax binds an object property to a function that will be called when that property is looked up. The set does the same when there is an attempt to set that property.
						</aside>
					</section>

					<section>
						<h2 style="font-size: 1.4em">Class methods</h2>
						<pre>
							<code data-trim>
								static defaultCharacter() {
									return new Character("Alex", 100, 10);
								}

								toString() {
									return `This is ${this.name} the ${this.constructor.name}`;
								}

								info() {
									return `${this.constructor.name} ${this.name}, health: ${this.health}, damage: ${this.damage}`;
								}
							</code>
						</pre>


						<aside class="notes">
							Static methods resemble prototype methods in the fact that they define the behaviour of the invoking object but differ from their prototype counterparts as they cannot be invoked by an instance of a class. As MDN describes it, “Static methods are called without instantiating their class and are also not callable when the class is instantiated.” In other words, static methods have no access to data stored in specific objects.
							toString() and info() are simple methods I added to show what a terse and clean syntax ES6 offers us.
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h2 style="font-size: 1.4em">Character's subclass</h2>
						<pre>
							<code data-trim>
								class Warrior extends Character {
									constructor(name, health, damage, defence) {
										super(name, health, damage);
										this.defence = defence;
									}

									info() {
										return (super.info() + `, defence: ${this.defence}`);
									}
								}
							</code>
						</pre>


						<aside class="notes">
							In object oriented programming, it’s a good practice to create a base class that holds some generic methods and attributes and then create other more specific classes that inherit these generic methods from the base. ES6 introduced the extends keyword that makes inheritance very easy. A subclass can easily inherit attributes from a base class like this:
							We have created a subclass here — Warrior. We make use of the super keyword within the constructor method of the Warrior class to invoke the super class’ constructor. Also the Warrior class overrides its parent’s method info() using, again, the super keyword to refer to parent’s method. And we can’t see it here, but Warrior class inherits the method of the Character class toString().
						</aside>
					</section>

					<section>
						<h2 style="font-size: 1.4em">Character's subclass</h2>
						<pre>
							<code data-trim>
								const warrior = new Warrior("Tom", 120, 15, 10);

								console.log(warrior.info()); //"Warrior Tom, health: 120, damage: 15, defence: 10"

								console.log(warrior.toString()); //"This is Tom the Warrior"
							</code>
						</pre>


						<aside class="notes">
							Okay, so if we try creating an instance of the Warrior class and invoke its own method and an inherited method, the result will be just as expected.
						</aside>
					</section>
				</section>

				<section>
					<section>
						<img src="https://wanago.io/wp-content/uploads/2018/03/prototype.png" alt="proto">


						<aside class="notes">
							At the beginning of the presentation, I said that most of the new keywords in ES6 are merely syntactical sugar over the existing prototype-based inheritance. Let’s now take a look under the sheets and see how the prototype chain works.
							While it’s nice to define classes and perform inheritance with the new ES6 keywords, it’s even nicer to understand how things work at the canonical level. Let’s take a look at JavaScript objects: all JavaScript objects have a private property that points to a second object (except for a few rare cases where it points to null) associated with them, this second object is called the prototype.
							If you request a property on an object that the object doesn't have, it says: "I don't know. Ask my prototype." and JavaScript checks the object's prototype for that property.
						</aside>
					</section>

					<section>
						<h2>Prototypes</h2>
						<pre>
							<code data-trim>
								const jessy = {name: 'Jessy'},
									tom = {name: 'Tom'};

								Object.hasOwnProperty(jessy, toString); //false
								Object.hasOwnProperty(tom, toString); //false

								jessy.toString(); //'[object Object]'
								tom.toString(); //'[object Object]'
							</code>
						</pre>


						<aside class="notes">
							Here we have 2 objects, neither of which has toString method. But we can call it anyway! That's because, while neither jessy nor tom has a toString property, their prototype – Object.prototype - does. And that’s the case. If several objects share the same prototype they can all access that prototype's properties, immediately after we assign them, without us having to copy those properties or methods to each individual object.
						</aside>
					</section>

					<section>
						<h2>Prototypes</h2>
						<pre style="font-size: 0.5em">
							<code data-trim>
								const Character = function(name, health, damage) {
									this.name = name;
									this.health = health;
									this.damage = damage;
								};

								const Warrior = function(name, health, damage, defence) {
									Character.call(this, name, health, damage);
									this.defence = defence;
								};
								Object.setPrototypeOf(Warrior.prototype, Character.prototype);

								const war = new Warrior("Jack", 100, 20, 15);

								console.log(Object.getPrototypeOf(war) === Warrior.prototype); //true
								console.log(Character.prototype.isPrototypeOf(war)) //true
							</code>
						</pre>


						<aside class="notes">
							Before ES6 spec was released, we had to set prototypes of newly created objects by hand if we wanted them to inherit properties of other object.
							Here we create Character and Warrior constructors, where Warrior “inherits” Character. A new object is created, inheriting from Warrior.prototype. Then we get the prototype of an object through the Object.getPrototypeOf function and see that so-called inheritance worked.
						</aside>
					</section>

					<section>
						<h2>Prototypes</h2>
						<pre>
							<code data-trim>
								const warrior = new Warrior("Tom", 120, 20, 15);

								console.log(typeof Warrior); // 'function'
								console.log(Object.getPrototypeOf(warrior) === Warrior.prototype); // true
								console.log(Character.prototype.isPrototypeOf(warrior)); // true
							</code>
						</pre>


						<aside class="notes">
							For clarity of presentation, I should remind you that ES6 classes are not a new language construction, all the work is done by prototypes under the hood. So if we create new objects using classes I’ve shown you before, we will see that these are just prototypes in the end.
						</aside>
					</section>
				</section>

				<section>
					<h2>What issues do classes solve?</h2>
					<ul>
						<li style="margin: 0.7em 0">We have a <span style="color: #901818">super</span> function inside of a constructor</li>
						<li style="margin: 0.7em 0">There is no need to call Object.setPrototypeOf</li>
						<li style="margin: 0.7em 0">You can extend any class easily and in a very natural way</li>
					</ul>


					<aside class="notes">
						What issues does it solve, aside from that? Quite a few, actually!
						We have a super function inside of a constructor – it calls a constructor of a class that is being extended.
						There is no need to call Object.setPrototypeOf to extend another prototype
						You can extend any class easily and in a very natural way.
						Understanding prototypes is one of the crucial tasks for an aspiring JavaScript developer. Currently, with the ES6 classes syntax popularized, it might seem even harder, as it implicates that there are some classes involved, but there aren’t any. It doesn’t make it less important though.
					</aside>
				</section>

				<section>
					<h2>Thanks for attention!</h2>
					<img style="width: 700px" src="https://cdn-images-1.medium.com/max/2000/1*0FZSrNhvMftanBIw9GZujw.png" alt="cat">
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
